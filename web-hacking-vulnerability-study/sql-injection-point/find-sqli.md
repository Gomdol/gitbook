# SQL Injection Point 찾기

### SQLi를 찾는 포인트

: <mark style="background-color:red;">**DB에게 SQL 질의문을 사용하는 곳**</mark>이다.

파라미터를 통해 SQLi가 되는지 테스트 해 볼 수 있다.



다음의 장소에서 주로 가능하다.

<mark style="color:red;">**1: cookie, HTTP 요청 헤더**</mark>&#x20;

<mark style="color:red;">**2: column**</mark>&#x20;

<mark style="color:red;">**3: order by 절 SQL Injection (**</mark><mark style="color:red;background-color:orange;">**중요, 실제 많이 일어남**</mark><mark style="color:red;">**)**</mark>



***

#### **기본 | like 절**



예를들어, **게시판에서 ID로 조회**한다고 가정한다.

where user\_id like '% \_\_\_ %' and '1' 이 되는지 테스트 해보자.

\_\_\_ 안에, 검색하려는 검색어 normaltic 중 일부인

1. nor
2. nor%' and '1%' = '1

1, 2의 결과가 같은지 확인해본다.

(같다면 SQLi 취약점이  있을수 있음.)



burpsuite의 파라미터, 헤더 정보를 통해서 분석해보자!





***

#### <mark style="background-color:blue;">**column 이름**</mark>**에 SQLi가 되는 케이스 | where 절**



option\_val=title&#x20;

board\_result=test



select where <mark style="background-color:orange;">option\_val</mark> like ' % sfUser %'&#x20;



: 쿼리가 먹히지 않는다. = title은 컬럼 이름으로 사용되고 있구나

라고 판단한다.



이 경우 SQLi가 되는지 확인하기 위해 평소와 다르게 쿼리를 작성한다.

X : title and '1' = '1'

<mark style="color:red;">**O : '1' = '1' and title**</mark>



위와 같이 작성할 때, SQL 구문이 다음과 같이 정상적으로 들어간다.&#x20;

select where **'1' = '1' and **<mark style="background-color:orange;">**title**</mark> <mark style="background-color:orange;"></mark><mark style="background-color:orange;">like ' % sfUser %'</mark>&#x20;

따라서 게시판 조회가 정상적으로 되는 것을 확인할 수 있다.



***

#### insert절



💡참고로 회원  가입은 insert문을 사용한다.

() 괄호 안에

insert values('') 이 안에 들어갈 것. insert values('normaltic' and '1'='1')

지금 이 <mark style="background-color:red;">**파라미터가 웹서버 SQL 구문 중 어디에 들어갈지**</mark>를 먼저 머리 속으로 그리고 그에 맞춰서 구문을 넣어야 한다.

> **쿠키**에서도 sql 인젝션이 가능하다!



***

#### order by절



게시판에서 **조건 (제목, 이름 등..)으로 검색**하는 것과 관련하여 아래 내용을 보자.



sort=title &#x20;

order by **title**



<mark style="color:red;">**\*\***</mark> 으로 검색하는 것은 sql문으로 <mark style="background-color:orange;">order by</mark> <mark style="background-color:orange;"></mark><mark style="background-color:orange;">**\*\***</mark> 이 들어갔다고 추정할 수 있다.



order by 절에서 SQLi가 작동하는지 확인하려면,&#x20;

<mark style="background-color:orange;">1, 2, 999999 등을 넣어서</mark>

작은 숫자일 경우 : 정상 작동

<mark style="background-color:orange;">**큰 숫자일 경우 : 작동하지 않음**</mark>

임을 확인하면 된다.

<mark style="color:red;">**\* 작동하지 않는 이유 : 컬럼 갯수를 초과했기 때문**</mark>



그럼 참과 거짓조건을 여기에 어떻게 쑤셔 넣을까?&#x20;

이어지는 **case when 문법을 활용**한다.



***

#### <mark style="background-color:orange;">case when 문법</mark>으로 참/거짓 판별하기



case when 문법 = sql 질의문에서의 if 문



**기본 공식** : case when (조건) then (참일 때) else (거짓일 때) end



case when (1=1) then <mark style="background-color:blue;">1</mark> else 2 end&#x20;

case when (1=2) then 1 else <mark style="background-color:blue;">2</mark> end

case when (1=1) then <mark style="background-color:blue;">username</mark> else title end&#x20;

case when (1=2) then username else <mark style="background-color:blue;">title</mark> end&#x20;

위와 같이 참/거짓을 확인함.



그런데 Column명을 정확하게 모를 때는 case when을 사용하기 어렵다.

그 경우에는 아래의 방법을 사용한다.



***

#### <mark style="background-color:orange;">**order by 절에서 Column명을 정확하게 모를 때**</mark>

#### 방식1.

case when (1=1) then 1 else (<mark style="color:red;">**일부러 에러를 유발하는 데이터**</mark>) end&#x20;

괄호 안에 99999 를 넣으면 된다고 생각하지만, 가끔 에러가 나지 않을 때가 있다.

(case when으로 실행하게 되면, 결과가 문자열로 출력되기 때문 -> 문자열로 출력되면 에러가 안 나고 그냥 정렬이 되기도 한다.)

그래서 다음과 같이 <mark style="background-color:orange;">아예 에러가 날 문법</mark>으로 적어준다.



case when (1=1) then 1 else (<mark style="background-color:blue;">select 1 union select 2</mark>) end

case when (1=2) then 1 else (<mark style="background-color:blue;">select 1 union select 2</mark>) end



위와 같이 쓰면, 행이 2개가 출력된다.

value가 아니라 matrix 이기 때문에 에러가 발생한다.



따라서 참인 경우에는 데이터가 잘 나오고 (게시판에 결과 출력됨), 거짓인 경우에는 데이터가 나오지 않는다.



#### 방식2.

<mark style="background-color:blue;">select 1 union select 2 where (1=1)</mark>



order by 절에 1 쓰는 것과 (select 1) 은 완전히 같은 것.

select 1 union select 2 where (1=1) 참이기 때문에 오류&#x20;

select 1 union select 2 where (1=2) 거짓이기 때문에 select 1만 나오기 때문에 출력이 됨.





